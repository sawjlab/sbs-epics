#!/usr/bin/perl
package LecroyHV_Shim;  ## needed for Net::Server -- do not remove this line

# Mod: 12-May-2014 RP: minor changes for use telnet connection in Expect().
#                      Add cvalue to variable: $hvserver = "localhost:24742"; to use to connect with HV1458 server    
# Mod: 05-Jun-2014 RP: changes for support TCP/IP protocol. In 'mux_input()' function add 'status code' (first 7 bytes)
#                      and null termination symbol at the end of response for sending to Java GUI: 
#       1               2 3 4 5                   7       8 ...            
#  <space_or_C>   <5 ASCII digits status_code>  <space>  <message>  <\0>
# if first symbol=space(0x20) then is one line in response,
# if first symbol=C(0x43) then there is next line in response.
# if status_code > 20 it is error message in response.
#                      Multiline responses(SYSINFO,ENET,...) from HV crate are modified for TCP/IP protocol also.

# Mod: 17-Apr-2021 BDS: Mods for compatibility with EPICS driver (which
#                       expects original Lecroy interface.)
# 14-May-2021 SAW:  Add Relay server
# Mod: 15-Mar-2017 RP: big changes for use with relay server for VDC HV control:
#                      - read configuration file with relay server parameters: host, port slot, chmap.
#                      - parse commands HVON,HVOFF,LD from GUI  to control relays

# TODO:
#   - Want to store current state information and send it on reload for each
#     unchanged slot/card combo
#     - data might be stored in the cards already?
#   - PUPSTATUS sends a hardcoded 'magic number', see HV1458_handler() for more
#     details.
#     - This is 'Power up status'  -- its structure is undocumented, and I don't
#       think I have access to the internal mainframe hardware status anyway...
#   - GS might benefit if LS is actived on an internal timer.  This would allow
#     GS to be incremented based on the updated LS data.  The Java client polls
#     both anyway, so it will not be affected.  Other clients may poll GS only
#     and use a change there to trigger an LS, etc.
#     - The poll could probably be implemented by a 'loopback' connection
#       through the mux.  I could throw and expect() on that mux that would
#       use a resetting timeout ($server->restart_timeout_upon_receive(1);)
#       to call LS_status every N seconds.  For now, I'll take the shortcut
#       described in the next note.
#     - NOTE: At the moment, GS gets a timestamp associated with it.  If the GS
#             data goes 'stale', then a new LS will be invoked to poll the
#             cards and allow GS to be updated in turn.
#   - Many command responses (ID, PROP, etc) could be cached in the LOGICALUNIT()
#     structure.  AFAICT, these aren't called much, so I didn't bother.
#   - Implement some reasonable hysteresis band for the LS_status changes
#     - see comments around %LS_PROP_LIST for more details
#   - Improve error handling
#     - easy: make retcode a global and set it in each command
#     - better: pass retcode back and pop it off the return list for each command
#   - Mainframe frontpanel HV panic and on/off buttons no longer interact
#     with the crate.  Normally such data are flagged/stored in 'GS' or 'CONFIG'
#     and managed in the mainframe host software (which no longer exists).
#     - at the moment, those front-panel buttons are essentially disconnected
#     - Front-end hardware changes would be needed to re-enable them, and
#       somehow propogate their state to the minimal hardware controller
#       frontend.  Perhaps it could maskerade as a special card (ex. slot 17)
#       that this software could interrogate and update the GS and CONFIG
#       status variables accordingly.
#
# FIXME:
#   - confirm HVON, HVOFF generate expected responses
#   - test how cards with submodules are really handled by real HW server
#     - S0 S1S0 S1S2 S2 ... SN contains sub-module info as shown
#     - L0, L1 .. L<n> enumerates over all sub-modules (ie. <n> doesn't
#       necessarily map to a physical slot
#   - Confirm that HV trips are flagged by the card and propogated through the
#     PSUM and slot data.
#   - Add proper command-line configuration options
#     - add/update Usage() information
#
# NOTES:
#   - Mulitple clients can connect and interact with the mainframe or snoop on
#     the traffic.  HOWEVER, _all_ responses are currently broadcast to all
#     clients -- this could confuse clients with 'unexpected' data.  There is
#     also a (potential?) issue with multiple command responses getting
#     interleaved on the output.  Each line response will be correct, and well
#     written clients should be watching for the approprate prefix to identify
#     its response, but YMMV.
#     - If this is determined to be a  Bad Thing(TM), then just set the
#       appropriate mux argument to limit to a single client connection.

my $vers = "1.1-EPICS";

use warnings;
use strict;
use Getopt::Long;
use Carp;
use Data::Dumper;
use Expect;
use base qw(Net::Server::Multiplex);
use IO::Socket::INET;

# 15-Mar-2017
# flush after every write
$| = 1;

$ENV{PATH}="/bin:/usr/bin";

##my $hvserver = "192.168.2.2:24742"; # for emulation on PC
my $hvserver = "localhost:24742";
#my $hvserver = "rpi1:24742";
my $slotlistfile = "/tmp/LecroySlotList.txt";

#$Expect::Debug = 1;
$Expect::Multiline_Matching = 1;

my $HVserverIO = new Expect;  # 'Expect' object that talks to the HV server
$HVserverIO->raw_pty(1);

my $HV_server_timeout = 5;

my $L1450_READY_PROMPT = '%d\EDIT\1450>';
##my $MF_READY_PROMPT    = 'lc232>';
my $MF_READY_PROMPT    = 'hvpi>';
my $EOL = "\r\f";
#my $EOL = "\0";

my $LSLOT_OUTPUT_FORMAT="%sL%03d%s";   # Use 3 digits w/ leading zeros
#my $LSLOT_OUTPUT_FORMAT="%sL%d%s";     # No leading zeros

my $verbose = 1;   # = 1 print verbosely
my $BROADCAST = 0; # = 1 then broadcast responses to all clients

###############################
###  Relay server 15-Mar-2017
###############################
# configuration file for relay server
my $rlyfilename = '/home/pi/relay.config';
# keep config parameters here
my %rlyparams; 
# keep map of hv channel(key) to relay channel(value) here
my %slotmap;
my $rlylu="";
my $RLY_USE=0; # if ==1, then using relay server, otherwise not
my $rly_psum="0000"; # relay property summary number(4-digit hex), incremented on every relay state changing
###

## Property summary (psum) data are at the root of several costly commands that
#  can pull data for all channels on all cards in the mainframe.  This allows the
#  psum data to be cached and considered constant for this many seconds.
my $PSUM_CACHE_TIME = 5;

## General summary (GS) data are assumed stale if an associated timestamp
#  indicates the underlying data have not been updated in this period
#  (seconds).
my $GS_STALE_TIME = 10;

## Every card is allocated N status words that get incremented on a change in
#  some of its attributes.  The 1461N module has two words that appear to map
#  to changes in any channels' MC or MV.  The java GUI has a hardcoded
#  assumption that it will always be two words per logical unit so that's what
#  I'll use.
#  20Apr2021 (BDS): changed word definition so one field notes changes in
#            measured values, and the second changes in demand values.
#    - The minimum change field was to set some hysteresis zone.  In the long
#      run, it would have to be copied into the logical unit map and vary for
#      each card -- perhaps based on some analysis of the precision field
#      reported by 'ATTR LX <prop>'
#      --> Leave it it at zero for now.  It is not useful as is.
my %LS_PROP_LIST = (
  "MEASURED" => {
    "idx" => 0,
    "test_params" => {
      "MC" => {"min_change" => 0},  # change in measured current value
      "MV" => {"min_change" => 0},  # change in measured voltage value
    },
  },
  "DEMAND" => {
    "idx" => 1,
    # "min_change" => 0,  # change in measured value  (not used...)
  },
);

## This is the word definition for the first word in the CONFIG response.
#  The only bits that really matter (ie. that the java client looks at
#  are the statusHVstate (which we keep up to date) and panicOFF, which
#  is no longer connected.
my %HVconfigW0;
$HVconfigW0{"settingsLocked"}=0<<0;   # (1 bit)
$HVconfigW0{"SWlimitsLocked"}=0<<1;   # (1 bit)
$HVconfigW0{"remoteSwitch"}  =1<<2;   # (1 bit)
$HVconfigW0{"statusEEPROM"}  =1<<4;   # (1 bit)
$HVconfigW0{"statusBattery"} =1<<5;   # (1 bit)
$HVconfigW0{"status24V"}     =1<<6;   # (1 bit)
$HVconfigW0{"statusPowerUp"} =1<<8;   # (2 bit) 0=not ready, 1 normal, 2=warning, 3=error
$HVconfigW0{"statusHVstate"} =0<<13;  # (2 bit) 0=HVOFF, 1=HVON, 2=HV changing, 3=HV unknown
$HVconfigW0{"panicOFF"}      =0<<15;  # (1 bit)

my %CRATE;
my @LOGICALUNIT = ();


__PACKAGE__->run();
exit;

#### 15-Mar-2017 #####
####
#******************************************************************
# rly_init() - init relay server parameters
##################################################################
sub rly_init() {
  # read connection parameters from configuration file
  if (read_rly_config()) {

      printlog ($rlyparams{'host'});
      printlog ($rlyparams{'port'});
      printlog ($rlyparams{'slot'});
      printlog ($rlyparams{'chmap'});

      my $resp = rly_send("RC S0 RLY");
      if(!$resp) {
         printlog("ERROR: No response from relay server $rlyparams{'host'}\n");	 
        return 0; # not success
      } 	  
      
      return 1;
  } else {
     printlog( "ERROR in read_rly_config()\n");
     return 0;
  }
}
#--------------------------------------------------------------------

#*********************************************************************
# read_rly_config - read relay configuration file in form: key=value 
#                   and put these parameters to hash table  'rlyparams'
#######################################################################
#open my $fh, '<', '/root/temp.txt' or die "Unable to open file:$!\n";
#my %hash = map { split /=|\s+/; } <$fh>;
#close $fh;
#print "$_ => $hash{$_}\n" for keys %hash;

sub read_rly_config() {
    if(open my $fh, '<', $rlyfilename) {
    %rlyparams = (); # clear hash
      while (my $row = <$fh>) {
        chomp $row;
	$row =~ /^$/ and next;
	$row =~ /^#/ and next; # skip comment line
#	print "$row\n";
    	(my $word1,my $word2) = split /=/, $row;
    	$rlyparams{$word1} = $word2;
      }
      close $fh;
#      print("\n");
#      print "$_ => $rlyparams{$_}\n" for keys %rlyparams;
      rly_parse();
    } else {
         printlog ("Could not open file $rlyfilename ");
	 return 0;
    }
    return 1;
}
#----------------------------------------------------------------

#***********************************************************************
#  rly_parse - parse hv channels to relay channels map from config file
#              and store it in 'slotmap' hash table
########################################################################
sub rly_parse() {
  %slotmap = (); # clear hash
  my @arr= split m{(?<!\.)\s+}, $rlyparams{"chmap"};
#  print "<@arr>";
#  chomp @arr;
#  %slotmap = map { split m{(\d+)\.(\d+)} } split m{(?<!\.)\s+}, $rlyparams{"chmap"};
#   %slotmap = map { $_ =~ /(\d+)\.(\d+)/ } split m{(?<!\.)\s+}, $rlyparams{"chmap"};
   %slotmap = map { $_ =~ /(\d+)\.(\d+)/ } @arr;
#   print "$_ => $slotmap{$_}\n" for keys %slotmap;

}
#------------------------------------------------------------------------
#************************************************************************
sub rly_parse_j() {
 my @arr = split m{(?<!\.)\\:},  $rlyparams{"rly.map"};
 my %slotmap = map {$_ =~ /(\w?\d+\.?\d+)\.(\d+)/ }  @arr;
# print "<@arr>";
# print "$_ => $slotmap{$_}\n" for keys %slotmap;

}
#------------------------------------------------------------------------

#***********************************************************************
# rly_send() - connect to relay server, send command and get response
#
########################################################################
sub rly_send($) {    
    my $rlysocket;
    my $cmd = shift;
    my $host_port= "$rlyparams{'host'}:$rlyparams{'port'}";

# creating object interface of IO::Socket::INET modules which internally creates 
# socket, binds and connects to the TCP server running on the specific port.
   if( $rlysocket = new IO::Socket::INET (
  	       PeerHost => $rlyparams{"host"},
	       PeerPort => $rlyparams{"port"},
	#PeerHost => '192.168.2.2',
	#PeerPort => '1090',
	       Proto => 'tcp',
	       Timeout  => 3,
	) 
   ) 
  {

    printlog ("TCP Connection to relay server($host_port):  Success.");

# write on the socket to server.
#  my $data = "RC S0 RLY";
#print $rlysocket "$data\n";
# we can also send the data through IO::Socket::INET module,
    $rlysocket->send($cmd);
    printlog ("sent to  relay server ($host_port): <$cmd>");

    my $response = "";
# read the socket data sent by server.
#$response = <$rlysocket>;
# we can also read from socket through recv()  in IO::Socket::INET
     $rlysocket->recv($response,255);
     chomp($response);
     printlog ("Replay from relay server: >$response<\n");
     return $response;

     $rlysocket->close();
     sleep (1);

  }  else {
     carp "ERROR in Relay Socket Creation for $host_port: $!\n";
     return "";
  }
}
#-----------------------------------------------------------------------
#**************************************************************************** 
# incr_rly_psum() - increment relay PSUM number
#
#############################################################################
sub incr_rly_psum() {
    printlog("incr_rly_psum(1):$rly_psum");
#    $rly_psum++;
#    printlog("incr_rly_psum(2):$rly_psum");
    my $dpsum=hex($rly_psum);
    $dpsum++;
    if($dpsum>=65536) { $dpsum=0;}
    $rly_psum = sprintf("%04X", $dpsum);
}
#-----------------------------------------------------------------------

#**************************************************************************** 
#  parse_host_cmd  - check command from GUI if it is related or not to relay server.
#  		     It checks command: HVON, HVOFF, LD, and properties 'DV' (demand voltafge),'EN' (enable/disable channel)
#                    and check replayes from hv module 
# 		     for RC command and property: 'ST' (hv channel status). 
#                    If it is related, then send command ON/OFF to relay server.
#		     Logic:
#                    if command HVOFF or HVON -> relay OFF (resistor in), delay 1 sec
#                    if command LD and (slot) and ('DV' or 'EN')-> relay OFF, delay 1 sec
#                    if command RC and (slot) and 
#		        property ST==1  -> relay ON (resistor out)
#
#	LD/RC command for relay server is the same as for hv module, slot - "S0" is meaningless, just to keep uniform protocol.
#	Examples:     
#	Load commands: 
#	    "LD S0.1 RLY 0"  - set relay channel number #1 (channel number starts from #0) to OFF(resistor IN)
#           "LD S0.2 RLY 1"  - set relay channel number #2 to ON (closed relay - resistor OUT)
#  	    	replay:"     1 LD S0.2 RLY 1"
#	    "LD S0 RLY 1 1 1 1 0 0 0 0"  - set relay channels number #0-#3 to ON and #4-#7 to OFF
#	    "LD S0 RLY 1 1 0 0"  - set relay channels number #0,#1 to ON and #2,#3 to OFF
#  	    	replay:"     1 LD S0 RLY 1 1 0 0 0 0 0 0"
#	Recall commands:	
#           "RC S0.2 RLY"  - get status relay channel number #2 (0 - OFF, 1- ON)
#	    	replay:"     1 RC S0.2 RLY 1"
#           "RC S0 RLY"  - get status of all relay channels (8) (0 - OFF, 1- ON)
#  	    	replay:"     1 RC S0 RLY 1 1 0 0 0 0 0 0"
##############################################################################
sub parse_host_cmd($@) {
  
  my $lslot="";
  my $slot="";
  my $chan="";
  my $prop="";
  my $lunit="";
  my $rly_chan="";
  my $val="";
## 
  my $rly_cmd_ld="LD S0"; # constant part of relay load command
  my $rly_cmd_rc="RC S0"; # constant part of raly racal command 
  my $rly_cmd="";
  my $rly_cmd_OFF="LD S0 RLY 0 0 0 0 0 0 0 0"; # command for OFF all ralay channels
  my $rly_cmd_ON="";

  my $command = shift;

  if( $RLY_USE ) {
  printlog("parse host command: <$command @_> \n");  
# single command  
  if( $command eq "HVON" or $command eq "HVOFF" ) {
    printlog ("-->>$command \n");  
    my $resp = rly_send($rly_cmd_OFF); # send command to relay server, should we check response???
    if($resp) {
      printlog ("Resp: $resp\n");
      incr_rly_psum(); # increment relay PSUM number
    } else {
      printlog ("ERROR: No response from relay server $rlyparams{'host'}\n");	 
      return 0; # not success
    }	
    return 1;
  }

  if( $rlyparams{"slot"} ) {
#    $lunit = shift; # logical unit (and channel) L0.1 or S0!? 
#    printlog ("-->>$command $rlylu $prop \n");

    if($command eq "LD") {  
      printlog ("-->>LD\n");  
##      $lslot = shift; # logical unit  L0 or S0 
##      $chan = shift; # channel number
##      $prop = shift; # property: ie 'DV'
##      $val = shift; # value(s): 0, 1,..

      $lslot = $_[0]; # logical unit  L0 or S0 
      $chan = $_[1]; # channel number
      $prop = $_[2]; # property: ie 'DV'
      $val =  $_[3]; # value(s): 0, 1,..

      if( defined($lslot) ) {
#      if( $lunit =~ /(\w?\d+)\.?(\d+)?/ ) {
#        $lslot = $1;
	printlog ("lslot=$lslot\n");
	return 0 if ( !($lslot eq $rlyparams{"slot"} or $lslot eq $rlylu) ); # check if slot in command equals to slot in relay config file
        if(length $chan) { 	    
	    printlog ("chan=\'$chan\'");
#        if(defined($2)) { 
#	   $chan=$2; 
	   $rly_chan=$slotmap{"$chan"};   # get relay channel

	   if(!defined($rly_chan)) { return 0;};   # no relay channel in table map 'slotmap', do nothing, just retrun.
	   $rly_cmd=$rly_cmd_ld . "." . $rly_chan . " RLY 0";   # relay command to OFF "LD S0.$rly_chan RLY 0"

	} else { 
# for all relay channels in %slotmap
	    my $rly_channels=" 0 0 0 0 0 0 0 0";   # send to all channels 
### FixMe!: need to be processed channel by channel from slotmap, or send "RC S0 RLY" command 
#           and get response. Then do OR  response with channel number from %slotmap.
#	 for (my $chi=0; $chi <= 11; $chi++) {	   
#	   if (exists $slotmap{$chi}) {
#	    $rly_channels=" 0";
#	   }
#	 }
	    $rly_cmd="LD S0 RLY".$rly_channels;   # "LD S0 RLY 0 0 0 0 0" 	  
	    printlog ("rlycmd=$rly_cmd");
	}
	   
      } else {
#       carp "'$command $lunit' has invalid format\n";
        printlog ("'$command $lunit' has invalid format\n");
        return 0;
      }    

      if( $prop eq "DV" or $prop eq "CE") { 
	  printlog ("---->>$prop\n");
#	  printlog ("<$rly_cmd>\n");
	  incr_rly_psum; # increment relay PSUM number
	  my $resp = rly_send($rly_cmd); # send command to relay server, should we check response???
	  if($resp) {
	   printlog("Resp DV,CE: $resp\n");
	   # increment RLY PSUM here
	   return 1;
	  } else {
	      carp("ERROR: No response from relay server $rlyparams{'host'}\n");	 
	      return 0; # not success
	  }
      }
      if( $prop eq "RLY" ) {
	  incr_rly_psum(); # increment rlay PSUM number
	  if( length($rly_chan)) {
	      if($val>0)  { $rly_cmd="$rly_cmd_ld.$rly_chan RLY 1";}
	      if($val==0) { $rly_cmd="$rly_cmd_ld.$rly_chan RLY 0";}
	      printlog ("RLY: <$rly_cmd>\n");
	      my $rly_resp = rly_send($rly_cmd); # send command to relay server, should we check response???
	      if($rly_resp) {
		  printlog("Rly_resp: $rly_resp\n");
	      # back mapping from relay channel to hv module channel
		  my $rly_val="";		 
		  # get last element (value)
		  $rly_resp =~ s/^\s+|\s+$|\0+//g; # remove whitespace at the beginning and at the end. 
		  my @arr= split(/\s+/, $rly_resp);
		  if(@arr) {
		      $rly_val=$arr[-1];
#		      printlog("rlyval=$rly_val");	
		      my $resp="$command $lslot.$chan $prop $rly_val.0"; # zero at the end is for compatability with GUI, it sends '0.0' instead of '0'
		      printlog("LD,RLY resp=$resp");		  
		      return $resp;
		  }
	      } else {
		  carp("ERROR in : No response from relay server $rlyparams{'host'}\n");	 
		  return 0; # not success
	      }	  
	  } else { # for all channels;
	      printlog("LD,RLY for all channels");
	      my @a_val = @_[3..$#_]; # values: 0, 1,..
	      my $cnt_chan=0;
#	      printlog(@a_val);
	      if(1) {
#		  my @a_val =  split(/\s+/, $val);
		      foreach  my $ch_val (@a_val) {		      
		      $rly_chan=$slotmap{"$cnt_chan"};   # get relay channel
		      printlog("chan=$cnt_chan val=$ch_val rlych=$rly_chan");
		      if((length $rly_chan)) { 
			  if($ch_val>0)  { $rly_cmd="$rly_cmd_ld.$rly_chan RLY 1";}
			  if($ch_val==0) { $rly_cmd="$rly_cmd_ld.$rly_chan RLY 0";}
			  printlog ("RLY: <$rly_cmd>\n");
			  my $rly_resp = rly_send($rly_cmd); # send command to relay server, should we check response???   
		      }
		      $cnt_chan++;
		  }
	      }
	      return "$command $lslot $prop ".join(" ",@a_val);
	    
	  }	      	  
      } # if "RLY"
      
      return 0;
    } # end if "LD"


    if($command eq "RC") { # we need to check replay from this command;
      printlog ("-->>RC\n");  
      $lslot =  $_[0]; # shift; # logical unit  L0 or S0 
#      $chan = shift; # channel number
      $prop =  $_[1] ; #shift; # property: ie 'DV'
      my $resp =  $_[2]; # shift; # replay from HV module

      if($prop eq "ST") {
	  if( defined($lslot) ) {
	      printlog ("lslot=$lslot\n");
	      return 0 if ( !($lslot eq $rlyparams{"slot"} or $lslot eq $rlylu) ); # check if slot in command equals to slot in relay config file
	      my @replay = split(/\s+/, $resp);
#	      printlog (@replay );
	      my $rep_cmd = shift @replay; # extract command from replay
	      my $rep_lu  = shift @replay;  # extract logic unit from raplay
	      my $rep_prop = shift @replay; # extract property from replay
#	      printlog (@replay );
	      ## check format of replay
	      if( defined($rep_cmd) and defined($rep_lu) and defined($rep_prop) ) {
		  my $cnt_chan=0;
		  foreach  my $stat (@replay) {		      
		      $rly_chan=$slotmap{"$cnt_chan"};   # get relay channel
#		      printlog("chan=$cnt_chan stat=$stat rlych=$rly_chan");
		      if(length($rly_chan)) { 
			  ## check channel status word
			  if( hex($stat) == 1 ) {# relay channel ON, no trips
			      $rly_cmd=$rly_cmd_ld . "." . $rly_chan . " RLY 1";   # relay command to ON "LD S0.$rly_chan RLY 0 
			      sleep (1);
			      my $rsp1 = rly_send($rly_cmd); # send command to relay server, should we check response???
			      incr_rly_psum(); # increment rlay PSUM number
			      if($rsp1) {
				  printlog("ON response: $rsp1\n");
			      }
#			      else {
#				  printlog("ERROR: No response from relay server $rlyparams{'host'}\n");	 
#				  return 0; # not success
#			      }				      
			  }
			  if( hex($stat) > 1) {# relay channel OFF
			      $rly_cmd=$rly_cmd_ld . "." . $rly_chan . " RLY 0";   # relay command to OFF "LD S0.$rly_chan RLY 0"
			      my $rsp2 = rly_send($rly_cmd); # send command to relay server, should we check response???
	                      incr_rly_psum(); # increment rlay PSUM number
			      if($rsp2) {
				  printlog("OFF response: $rsp2\n");
			      }
			  }			   
		      }
		      $cnt_chan++;
		  }
	      }
	  } else {
#       carp "'$command $lunit' has invalid format\n";
	      printlog ("'$command $lunit' has invalid format\n");
	      return 0;
	  }    

      } # if "ST"

      if($prop eq "RLY") {
	  ;
      }

      return 0;
    } # end if "RC"
  }
  }
  return 0;
}
#---------------------------------------------------------------------------
###


#########################################################
# Set default values for options
#########################################################
# FIXME:  this isn't called yet
sub default_values {
  #carp("default_values\n");
  return {
    help => 0,
    maxclients => 2,
    port => 2001,
    log_level => 2,
    broadcast => 0,
  }
}

#########################################################
# Add addtional options to those handled by Net::Server
#########################################################
sub options {
# FIXME:  not sure if this is called
  #carp("options\n");
  my $self = shift;
  my $prop = $self->{server};
  my $template = shift;

  ### setup options in the parent classes
  $self->SUPER::options($template);

  $prop->{'help'} ||= 0;
  $template->{'help'} = \$prop->{'help'};

  $prop->{'maxclients'} ||= 1;
  $template->{'maxclients'} = \$prop->{'maxclients'};

  $prop->{'broadcast'} ||= 0;
  $template->{'broadcast'} = \$prop->{'broadcast'};

}

#########################################################
# Usage description
#########################################################
sub usage($) {
  my $self = shift;
  my $prop = $self->{"server"};

  print << "  DONE"
  Usage: $0 [OPTION]

  Connects to a portserver (via telnet) which is communicating with the backend
  card interface on a LeCroy 1458 HV crate.  This program emulates the software
  normally running internal to the crate that provides a simplified control
  interface.

    -h, --help        List this help message
##  -S, --server      Portserver address:port [$hvserver]
    -B, --broadcast   Broadcast to all connected clients
    -M, --maxclients  Maximum number of clients that can connect [$prop->{maxclients}]

    See Net::Server(3pm) man page for additional paramaters.  A subset is presented below.
    --port=port       allow inbound connections on <port>        [$prop->{port}]
    --log_file=file   log messages to <file>                     [$prop->{log_file}]
    --log_level       0=off, higher=more verbose                 [$prop->{log_level}]
    --background      fork and background this process
    --pid_file=file

  DONE
}

#########################################################
# Validate options here & start connection to HV server
#########################################################
sub post_configure_hook {
  #carp("post_configure_hook\n");
  my $self = shift;
  my $prop = $self->{"server"};
  my $sock = $prop->{"client"};

  # FIXME: handled internally?
  $self->{"net_server"}->{"num_connections"}=0;

  #open(STDERR, ">>". $self->{error_log})  || die "Couldn't open STDERR: $!";
  #open(ACCESS, ">>". $self->{access_log}) || die "Couldn't open ACCESS: $!";

  #carp Dumper($self) . "\n";

  if ( $prop->{'maxclients'} <= 0 ) {
    printlog( "  Invalid argument for 'maxclients' option.  Exitting.");
    exit 1;
  }

  if( $prop->{"help"} ) {
    usage($self);
    exit 0;
  } 
}

#########################################################
# Handles inbound data coming from the GUI (or other remote inbound connection)
#   This routine grabs a line and sends it to HV1458_handler().  That function
#   talks to the hardware and responds and appropriately formatted string that
#   can be passed back to the GUI.
#########################################################
sub mux_input {
  my $self = shift;
  my $mux  = shift;
  my $fh   = shift;

  my $in_ref = shift;  # Scalar reference to the input

  my $peer = $self->{'peeraddr'};
  my $id   = $self->{'id'};

  # Check what termination is used by client.
  # Use that termination in response
  my $eol = "\0";
  if($$in_ref =~ /[\n]/) {
      $eol = "\r\f";
      # printlog ("Telnet");
      #} else {
      #   printlog ("TCP");
  }
  # Process each line in the input, leaving partial lines
  # in the input buffer
  while ($$in_ref =~ s/^([^\r]*?)[\r\n\0]+//) {
##  while ($$in_ref =~ s/^([^\r]*?)[\0]+//) {
    #next unless $1;
    my $message = $1;
    if ( $verbose == 1 ) {
       printlog ("[$id - $peer]: $message");
    }

    my $response = HV1458_handler($message);
    if ( $verbose == 1 ) {
      printlog ("[R] '$response'");
    }

    #  Check number of lines in response. It seems that module does not have responses with more then one line.
    #  Only HV crate have responses with few lines.
    my $nr_of_lines = $response =~ tr/\n//;
##    printlog ("NUM LINES: $nr_of_lines");

    if ($response =~ m/\n/) {  
	## Replace the newlines with the $EOL chars expected by the client
	## Echo the client's commmand back too
	$response =~ s/\n/$eol/gm;
    } else {
	$response = $response . $eol;
    }

    # This comment from VDC shim
    ##### FixMe!: this is not working, since there no return code(error code) in responses from module
    my $retcode = ($response =~ /^\s*$/) ? 127 : 1;

    ## prepare status code for TCP/IP protocol
    my $statuscode=sprintf(" %5d ", $retcode); 

    printlog("mux_input():StatusCODE=>$statuscode<  <$response>");
    if($nr_of_lines > 1) { 	
	$self->broadcast($mux,"$response$eol");
    } else {
	$self->broadcast($mux,"$statuscode$response");
    }
	
##    $self->broadcast($mux,"$message$EOL$response$EOL");
##    $self->broadcast($mux, sprintf("$L1450_READY_PROMPT", $retcode));
  }
}

#########################################################
# Called when inbound TCP connection is dropped
#########################################################
sub mux_close {
  #carp("mux_close\n");
  my $self = shift;
  my $mux  = shift;
  my $fh   = shift;
  my $peer = $self->{"peeraddr"};

  ## If mux_connection has actually been run
  if (exists $self->{"id"}) {
#    $self->broadcast($mux,"LEFT: (#$self->{id}) from $peer");
      printlog( "DEBUG: Client [$peer] (id $self->{id}) closed connection!");
      $self->{'net_server'}->{'num_connections'}--;

  }
}

#########################################################
# This callback will happen when the mux->set_timeout expires.
#########################################################
sub mux_timeout {
  my $self = shift;
  my $mux  = shift;
  my $fh   = shift;
  printlog("DEBUG: HEARTBEAT!");
# NOTE: This is presently disabled and is dead code.  Enable with
#  $mux->set_timeout($fh, 20);
# Example code here:
#  if ($self->{state} eq "junior") {
#    print "Whoa, you must have a lot of patience.  You have been upgraded.\n";
#    $self->{state} = "senior";
#  } elsif ($self->{state} eq "senior") {
#    print "If you don't want to talk then you should leave. *BYE*\n";
#    close(STDOUT);
#  }
#  $mux->set_timeout($fh, 40);
}


#########################################################
# Check if inbound tcp connection should be allowed
#########################################################
sub allow_deny_hook {
  #carp("allow_deny\n");
  my $self = shift;
  my $prop = $self->{"server"};

  my $max_clients = $prop->{'maxclients'};

  return 1 if( $self->{"net_server"}->{"num_connections"} < $max_clients );

  return 0;
}
sub request_denied_hook {
  #carp("deny_request\n");
  my $self = shift;
  my $prop = $self->{"server"};

  my $max_clients = $prop->{'maxclients'};
  printlog (sprintf("Connection request from %s denied. \n\t%d clients (max: %d) connected.\n",
            $prop->{"peeraddr"}, $self->{"net_server"}->{"num_connections"}, $max_clients));
}

#########################################################
# Routine to send a message to all clients in a mux.
#########################################################
sub broadcast {
  my $self = shift;
  my $mux  = shift;
  my $msg  = shift;
  my $prop = $self->{"server"};
  my $id   = $self->{'id'};

  #carp("broadcasting($msg)\n");
  foreach my $fh ($mux->handles) {
    my $mux_id = $mux->{_fhs}->{$fh}->{object}->{id};
    # NOTE: All the client unique objects can be found at
    # $mux->{_fhs}->{$fh}->{object}
    # In this example, the {id} would be
    #   $mux->{_fhs}->{$fh}->{object}->{id}
    print $fh $msg if( $BROADCAST || ($mux_id == $id) );
  }
}


#########################################################
# Called on Start/Restart of this server
#########################################################
#sub restart_open_hook {
#}

#########################################################
# Make connection to the HV mainframe
#########################################################
sub pre_loop_hook {
  #carp("restart_open_hook\n");
  my $self = shift;
  my $prop = $self->{"server"};

  ## Initiate connection to 1458 server
  my $dev="/dev/ttyS0";
  my $lock = $dev;
  $lock =~ s/^.*\//\/var\/lock\/LCK../;
  #my @server_cmd = ("/home/brads/bin/socat","-L$lock","-","$dev,raw,echo=0,crnl");    # through serial port

  #my @server_cmd = ("/usr/bin/socat","-","EXEC:'/usr/bin/ssh -t brads\@hacweb5',pty,setsid,ctty,crnl");

  #my @server_cmd = ("/usr/bin/ssh","-t",'brads@hacweb5','stty -echo && LecroyHV_FE/i2lchv_linux_brad');# via ssh
  #my @server_cmd = ("/usr/bin/ssh","-t",'brads@hacweb5','stty -echo && LecroyHV_FE/i2lchv_linux_brad 2>stderr.out');# via ssh

 #my @server_cmd = ('/shim/LecroyHV_shim/LecroyHV_FE/i2lchv_linux_S0 2>stderr.out');
 #my @server_cmd = ('/home/pi/shim/LecroyHV_shim/LecroyHV_FE/i2lchv_linux_AMA0 2>stderr.out');
   
 
  #my @server_cmd = ("/usr/bin/socat","-","TCP4:localhost:5555,crnl");

  ## FIXME: hvserver needs to be added to options list
  my ($HVhost, $HVport) = split(/:/,$hvserver,2);
  my @server_cmd = ("/usr/bin/telnet","$HVhost","$HVport");                          # telnet using telnet

  #my @server_cmd = ("/home/brads/bin/socat","-","$hvserver");                        # telnet using socat

  ## $HVserverIO = Expect->spawn( @server_cmd ) or
  ##  croak "Cannot connect to server: $!\n", "\tCommand used: '", join(" ", @server_cmd), "\n";

  #$HVserverIO->debug(3);
  #$HVserverIO->exp_internal(1);
  ## $HVserverIO->log_stdout(0);   # This must be disabled or MF traffic will be sent to the clients

  ## Or by using all perl equivalents:
  #my $telnet = new Net::Telnet( [ HOST => $HVhost, ]
  #                              [ PORT => $HVport, ]
  #                              );
  #$HVserverIO = Expect->exp_init($telnet) or
  #  croak "Cannot connect to server: $!\n", "\tCommand used: Net::Telnet($HVhost, $HVport)\n";

  # auto-flush on socket
  $| = 1;
 
  # create a connecting socket
  my $socket = new IO::Socket::INET (
      PeerHost => $HVhost,
      PeerPort => $HVport,
      Proto => 'tcp',
  );
  $HVserverIO = Expect->exp_init($socket) or
    croak "Cannot connect to server: $!\n", "\tCommand used: IO::Socket::INET($HVhost, $HVport)\n";

  init_LeCroy1458($HVserverIO);
}

#########################################################
# Called when inbound TCP connection (from GUI) closes
#########################################################
sub restart_close_hook {
  carp("restart_close_hook\n");
  my $self = shift;
  my $prop = $self->{'server'};

  # FIXME: connection count handled internally?
  $self->{'net_server'}->{'num_connections'}--;

  printlog ("Inbound TCP connection dropped, %d clients still connected.",
    $self->{'net_server'}->{'num_connections'});

  ## Kill the connection to the HV server
  #$HVserverIO->soft_close();
  $HVserverIO->hard_close();
}

#########################################################
# Called when input client clears the allow_deny_hook and 
# generates a full connection
#########################################################
sub mux_connection {
  carp("mux_connection\n");
  my $self = shift;
  my $mux  = shift;
  my $fh   = shift;

  my $peer = $self->{'peeraddr'};

  ## {server} hash is volatile, cache values current to this connection now
  $self->{'id'}       = $self->{'net_server'}->{'server'}->{'requests'};
  $self->{'peerport'} = $self->{'net_server'}->{'server'}->{'peerport'};

  printlog("Welcome $peer, you are number $self->{id} to connect.");

  ## Could also set a timeout on the inbound TCP connection here
  #  $mux->set_timeout($fh, 20);
  #  mux_timeout() callback gets triggered after timeout

  #FIXME: I think this is handled internally?
  $self->{'net_server'}->{'num_connections'}++;

  #NOTE: This broadcast could collide with another client request, but maybe
  #       that's the penalty for allowing multilple clients...

##  $self->broadcast($mux, sprintf($L1450_READY_PROMPT, 1));
}

sub printlog {
  my $message_string = join("", @_);
  my $date_string = localtime();

  chomp($message_string);
  ## $self->log might only be for syslog interface?
  #$self->log(2, "$date_string --> '$message_string'\n");
  print STDERR "------> ($date_string) $message_string\n";
}

##############################################################################
# - Converts the command from the client (2nd arg) to the raw command
#   used by the HV backend handled by $server (1st arg).
#    - sends it to the server, 
#    - waits for and parses the response if necessary
#    - return() the parsed response to the caller in the 'standard' format
##############################################################################
sub HV1458_handler($) {

  my $full_command = shift;
  $full_command =~ tr/[a-z]/[A-Z]/;

  my @cmd_arg = split(/\s+/, $full_command);
  my $command = shift(@cmd_arg);

  my $lslot="";
  my $slot="";
  my $subm="";
  my $chan="";
  my $prop="";
  my $resp="";

  if ( $verbose == 1 ) {
    printlog("HV1458_handler: '$full_command'");
  }

  if( !defined($command)) {
    return "";
  }

  if($command eq "1450") {
    my $resp = "1450 Session already activated.";
    return $resp;
  }

  if($command eq "DATE") {
    #1\EDIT\1450>date
    #date 11-MAY-1994
    my $resp = "20-JUL-1972";
    return $resp;
  }

  if($command eq "IMOFF") {
    #1\EDIT\1450>imoff
    #IMOFF
    my $resp = "Not implemented";  #FIXME
    return $resp;
  }

  if($command eq "SYSDEF") {
    #1\EDIT\1450>sysdef
    #sysdef 000B
    my $resp = "Not implemented";  #FIXME
    return $resp;
  }

  if($command eq "RM") {
    my $resp = "Not implemented";  #FIXME
    return $resp;
  }

  if($command eq "SM") {
    my $resp = "Not implemented";  #FIXME
    return $resp;
  }

  if($command eq "HI") {
    my $resp = "Hi! How are You?";
    return $resp;
  }

  if($command eq "LL") {
    return LL_filled_slots();
  }

  if($command eq "INIT") {
    init_LeCroy1458($HVserverIO);
    return;
  }

  if($command eq "DUMP") {
    $resp .=  "LOGICALUNITS: \n" . Dumper(@LOGICALUNIT) . "\n";
    $resp .=  "CRATE: \n" . Dumper(%CRATE) . "\n";
    printlog($resp);
    return $resp;
  }

  if($command eq "BROADCAST") {
    $BROADCAST = $BROADCAST ? 0 : 1;
    $resp = "Toggling broadcasting: " . $BROADCAST . "\n";
    printlog($resp);
    #return $resp;
    return "";
  }

  if($command eq "ENET") {
    # TODO: This should probably report the remote/telnet session information
    my $resp = "C    1 ENET
C    1 IP 192.168.1.2
C    1 GATEWAY 192.168.1.1
C    1 MASK 255.255.255.0
C    1 PORT 1090
C    1 TELNET YES
C    1 FTP YES
C    1 BSD YES
C    1 HTTP NO
*    1 PHYS 000000000000";

    $resp =~ s/^[ \t]*//gm;
    return $resp;
  }

  if($command eq "SYSINFO") {
    my $resp = "C    1 SYSINFO
C    1 LeCroy Model:      1458
C    1 HW Revision:       SOFT
C    1 HW ECO:            0000
C    1 Test Date:     12/34/56
C    1 Tested by:        brads
C    1 FW Version:       $vers
C    1 FW Date:    Jan 01 1970
C    1 FW Time:       00:00:00
C    1 Mainframe S#:  DEADBEEF
C    1 Op Hours:             0
C    1            
*    1  LeCroy Research Systems";

    $resp =~ s/^[\n \t]*//gm;
    return $resp;
  }

  if($command eq "HVSTATUS") {
    my $resp = poll_HV_status();
    return $resp;
  }

  if($command eq "LD") {
    # write/load a value to a property
    # Client to bbps1:2002:LD L12 CE 1 1 1 1 1 1 1 1 1 1 1 1
    # Client to bbps1:2002:LD L14.0 CE 1
    my $lunit = shift(@cmd_arg);
    if( $lunit =~ /(\w?\d+)\.?(\d+)?/ ) {
      $lslot = $1;
      $lslot = normalize_lslot($lslot);
      if(defined($2)) { $chan=$2; }
    } else {
      carp "'$command $lunit' has invalid format\n";
      return "";
    }
    my $prop = $cmd_arg[0]; # get property;
    my $parse_resp=parse_host_cmd($command, $lslot, $chan, @cmd_arg);  ###
##    printlog(">>@cmd_arg<< ($parse_resp)");
    if($parse_resp) {
	if($prop eq "RLY") {
	    return $parse_resp; # replay of command for relay server
	}
    }
    my $resp = load($lslot, $chan, @cmd_arg);
    return $resp;
  }

  if($command eq "HVON") {
    ## FIXME need examples of how the real server responds
    my $resp=parse_host_cmd($command); ###???  
    $resp = HV_card_power($command);
    return $resp;
  }

  if($command eq "HVOFF") {
    ## FIXME need examples of how the real server responds
    my $resp=parse_host_cmd($command);   ###???
    $resp = HV_card_power($command);
    return $resp;
  }

  ## Return the property list associated with the card
  if($command eq "PROP") {
    $lslot = shift(@cmd_arg);   # card/slot index: ie 'L4'
    $lslot = normalize_lslot($lslot);

    my $resp = properties($lslot);
    return $resp;
  }

  ## Return information about the card associated with the card
  if($command eq "ID") {
    $lslot = shift(@cmd_arg);   # card/slot index: ie 'L4'
    $lslot = normalize_lslot($lslot);

    my $resp = id($lslot);
##    $resp = normalize_lslot_output($resp);
    ## FIXME: HW board isn't returning a trailing 0 that the real mccoy returns so I add it here..
    return "$resp 0";
  }

  ## Return a description of the associated property
  if($command eq "ATTR") {
    $lslot = shift(@cmd_arg);   # card/slot index: ie 'L4'
    $lslot = normalize_lslot($lslot);
    $prop = shift(@cmd_arg);    # property: ie 'MC'
    $resp = attributes($lslot, $prop);
##    $resp = normalize_lslot_output($resp);
    return $resp;
  }

  ## Get numbers for all properties associated with a single channel
  if($command eq "DMP") {
    ## slot.chan index: ie 'L4.10'
    my $lunit = shift(@cmd_arg);
    if( $lunit =~ /(\w?\d+)\.(\d+)/ ) {
      $lslot = $1;
      $lslot = normalize_lslot($lslot);
      $chan = $2;
    } else {
      carp "'$command $lunit' has invalid format\n";
      return "";
    }

    $resp = dmp($lslot, $chan);
#    $resp = normalize_lslot_output($resp);
    return $resp;
  }

  ## Recall the current value of an property for all channels
  if($command eq "RC") {
    $lslot = shift(@cmd_arg);   # card/slot index: ie 'L4'
    $lslot = normalize_lslot($lslot);
    $prop = shift(@cmd_arg);   # property ie 'MC'

    if ( $RLY_USE==1 ) {
	if( $prop eq "RLY" ) {
	    $lslot=get_logical_unit($lslot) if ($lslot =~ /^S\d+(S\d+)?$/i); 
	    return sprintf("%s %s", $command, $prop ) if( !check_lslot($lslot) );

	    if ( ($lslot eq $rlyparams{"slot"} or $lslot eq $rlylu) ) {
		my $rly_cmd="$command $lslot $prop";
		my $r_resp =  rly_send($rly_cmd);
		$r_resp =~ s/^\s+|\s+$|\0+$//g; # remove whitespace at the beginning and at the end (and '\0'). 
		printlog("rresp=$r_resp\n");
		my @rlyresp = split(/\s+/, $r_resp);
##		$r_resp = shift(@rlyresp);
                # check number of channel in hv module relative to number of channels(8) in relay box
		my $card = $LOGICALUNIT[num_only($lslot)];
		my $num_chan = $card->{"num_chan"};
		printlog("num_chan=$num_chan");
		if( $num_chan>8) { #add  0 to number for number of channels for relay.
		    my $ch_cnt= $num_chan-8;
		    while ($ch_cnt>0) {
			push @rlyresp, "0";
			$ch_cnt--;
		    }
		}
		@rlyresp = @rlyresp[1 .. $#rlyresp];    # knock off the first response element: return code
		## remap channels from relay to hv module
##           
		my @m_chan=();
		my $ch_indx="";
		while ($num_chan>0) {
		    $ch_indx=$num_chan-1;
		    my $r_chan=$slotmap{"$ch_indx"};
		    if(defined($r_chan)) {
			$m_chan[$ch_indx]=$rlyresp[3+$r_chan];
		    } else {
			$m_chan[$ch_indx]="0";
		    }
		    $num_chan--;
		}
		printlog("@rlyresp, @m_chan");

#		$resp =  join(" ",@rlyresp);
		$resp =  "RC $lslot $prop ".join (" ",@m_chan);

#		return sprintf("%s %s %s 1 0 0 1 0 0 0 0 0 0 0 0",$command, $lslot, $prop); # add more 4 channels
##                $resp = "$command $lslot $prop 1 0 0 1 0 0 0 0"; # 
#		return sprintf("%s %s %s 1 0 0 1 0 0 0 0",$command, $lslot, $prop); 
		return sprintf("%s", $resp);
	    }
	}
    }
    $resp = recall($lslot, $prop);
### check replay for ST property (channel status): bit0==1 (channel enabled), then set VDC relay to ON, 
### if bit1-bit7 >0 (ramping or trip condition), then set relay to OFF
    if( $prop eq 'ST' ) {
# check slot
	my $lunit = $lslot;
	if( $lunit =~ /(\w?\d+)\.?(\d+)?/ ) {
	    $lslot = $1;
	    if(defined($2)) { $chan=$2; }
	} else {
	    carp "'$command $lunit' has invalid format\n";
##	    return "";
	}
	parse_host_cmd($command, $lslot, $prop, $resp);
    }
##    $resp = normalize_lslot_output($resp);
    return $resp;
  }

  ## Property summary list.  Each word gets incremented when there is a change
  #  in the associated property.
  if($command eq "PSUM") {
    $lslot = shift(@cmd_arg);
    $lslot = normalize_lslot($lslot);
    $resp = psum($lslot);
##    $resp = normalize_lslot_output($resp);
    return $resp;
  }

  ## LS, GS, PS, PUPSTATUS, CONFIG information gleaned from observation and 
  #  http://cdsweb.cern.ch/record/689249/files/INT-1999-42.ps.gz
  #  http://www.jlab.org/~brads/Manuals/Hardware/Lecroy_1450_INT-1999-42.pdf
  if($command eq "LS") { # logical unit summary?
    #  TODO: confirm this is working the way the client expects
    # N words for each module related to the number of "monitored / set" value
    # used by that module
    #   ie. for a crate full of 1461N cards, there are two words per module recording changes to:
    #      measured voltage?
    #      demand voltage?
    # HV java gui has hardcoded assumption that there are only 2 words per card
    # LOG: Client to hatsv3:2005:LS
    # LS A242 0007 A77F 0007 B611 0007 B685 0007 53A1 0007 0041 0007 85CD 0007 0006 0007 0003 0007 B6C3 0007 0014 0007 004C 0007 0003 0007 0003 0007 0003 0007 5B27 0007
    $resp = LS_status();
    return $resp;
  }

  if($command eq "PS") { # Property summary?
    $lslot = shift(@cmd_arg);   # slot index: ie 'L4'
    $lslot = normalize_lslot($lslot);
    #  There is one word associated with each property for a module
    #  - a word gets incremented if there is any change to that property
    #  TODO: confirm this is working the way the client expects
    #         - Looks like Mainframe might just call the PSUM command behind the scenes(?)
    #  LOG: Client to hatsv3:2005:PS L0
    #  PS L0 191F 0021 0001 0001 0001 0001 0001 00D8 0001 0001 0001
    $resp = psum($lslot);

    $resp =~ s/PSUM/PS/;
##    $resp = normalize_lslot_output($resp);
    return $resp;
  }

  if($command eq "GS") {
    ## These get incremented whan associated property is modified
    # Five numbers related to:
    # 1) measured values,
    # 2) demand values,
    # 3) mainframe configuration values,
    # 4) mainframe activity number,
    # 5) host activity number of all modules (this increments on each gs, anyway...)
    #  NOTE: The java client tests first 3 words, and does an LS check on 1,2
    #        and a CONFIG check on 3.  Some testing with a fully functional crate
    #        was used to guess some policy for 4 and 5.
    #         - (1) can trigger off LS_status check vs. old status stored in %CRATE{LS}
    #           - if an internal LS poll is implemented, then we can update there too
    #         - update (2) when load() is called
    #         - (3) never changes (no MF status)
    #               FIXME: HVON/OFF state is in here somewhere?
    #         - update (4) on any transaction with the internal cards
    #         - update (5) on each 'GS' call...
    # LOG: Client to hatsv3:2005:GS
    # GS FD3B 0095 0078 FDAD 0001
    $resp = GS_status();
    return $resp;
  }

  if($command eq "PUPSTATUS") { # powering up status
    # FIXME: not sure how this is constructed
    # "3 words describing the powering up procedure"
    # This is polled by the java gui, but doesn't seem to be used
    #
    ## LOG: Client to hatsv3:2005:PUPSTATUS
    ## PUPSTATUS 3 170 185
    #
    #NOTE: Using '3 170 185' as a "magic" number -- no idea what it means, but
    #      it seems stable after crate is powered and running.  No mainframe
    #      information is accessable by us, so this is filler.
    #return "PUPSTATUS 3 170 185";
    return "PUPSTATUS 1 1 1";
  }

  if($command eq "CONFIG") {
    # This is 5 4-digit ASCII hexadecimal words encoded with HV mainframe
    # configuration information.  The rather complicated word definition is
    # described on p.28
    #    http://cdsweb.cern.ch/record/689249/files/INT-1999-42.ps.gz
    #    http://www.jlab.org/~brads/Manuals/Hardware/Lecroy_1450_INT-1999-42.pdf
    # It includes status flags for things like EEPROM, low-Voltage supply,
    # battery, external hardware panic on/off, hardware switch settings, etc.
    #   word 0: <constructed below>
    #   word 1: serial comm info
    #   word 2: arcnet comm info
    #   word 3: summary number for SW limit values
    #   word 4: system default word 
    # LOG: Client to hatsv3:2005:CONFIG
    # LOG: CONFIG 2374 0001 0000 0072 000B
    #
    $resp = config_status();
    return $resp;
  }
}

sub normalize_lslot($) {
  my $lslot=shift;

  if($lslot =~ /L(\d+)/) {
    $lslot=sprintf("L%d", $1);
  } else {
    printlog(sprintf("warning: badly formated lslot '$lslot'\n"));
  }
  return $lslot;
}

#sub normalize_lslot_output($) {
#  my $cmd=shift;
#
#  if($cmd =~ /^(.*\s+)L(\d+)(\s+.*)$/) {
#    $cmd=sprintf($LSLOT_OUTPUT_FORMAT, $1, $2, $3);
#  }
#  return $cmd;
#}

## Report CONFIG state for crate
sub config_status() {
  my $W0 = 0;
  for my $k ( keys( %HVconfigW0 ) ) {
    $W0 += $HVconfigW0{$k};
  }
  my $resp = sprintf("CONFIG %04X 0001 0000 0072 000B", $W0);
  return $resp;
}

## Report LS state for all cards in the crate
# ie: LS A242 0007 A77F 0007 B611 0007 B685 0007 53A1 0007 0041 0007 85CD 0007 0006 0007 0003 0007 B6C3 0007 0014 0007 004C 0007 0003 0007 0003 0007 0003 0007 5B27 0007
sub LS_status() {
  my $LS_resp = "LS";

  my $meas_change   = 0;
  my $demand_change = 0;

  foreach my $card ( @LOGICALUNIT ) {
    my $slot =   $card->{"slot"};
    my $submod = $card->{"submod"};
    my $lslot =  $card->{"lslot"};

    $LS_resp .= " ";
    my @old_LS = @{$card->{"LS"}};
    my $resp = update_LS_card($lslot);
    if ( $resp =~ /^\s*$/ ) {
      $LS_resp .= join(" ", @{$card->{"LS"}} );
    } else {
      $LS_resp .= $resp;
    }

    $meas_change++   if($old_LS[0] ne $card->{"LS"}[0]);
    $demand_change++ if($old_LS[1] ne $card->{"LS"}[1]);
  }

  update_GS_status("MEAS")   if($meas_change);
  update_GS_status("DEMAND") if($demand_change);

  $CRATE{"t_GS_meas"} = time();
  $CRATE{"LS"} = $LS_resp;
  return $LS_resp;
}

## Incrments the GS change counter for the passed field/category
sub update_GS_status($) {
  my $type = shift;

  if( !exists($CRATE{"GS"}{"$type"}) ) {
    printlog("Invalid type ($type) used in update_GS_status()");
    return;
  }

  $CRATE{"GS"}{"$type"}++;
  return;
}

## Report GS state for mainframe
sub GS_status() {
  my $GS="";

  my $t_cur   = time();
  my $t_cache = $CRATE{"t_GS_meas"};
  if( ($t_cur - $t_cache) > $GS_STALE_TIME ) {
    if ( $verbose == 1 ) {
      printlog( "Updating stale GS.\n" );
    }
    LS_status;
  }

  $CRATE{"GS"}{"HOSTACTV"}++;
  $CRATE{"GS"}{"MFACTV"}++;

  for my $key ("MEAS", "DEMAND", "MFCONF", "MFACTV", "HOSTACTV") {
    $GS .= sprintf(" %04X", $CRATE{"GS"}{$key}%65536);
  }

  return "GS$GS";
}

## Updates the 2 word 'LS' status for a card and returns them as 
## space delimited hex string
sub update_LS_card($) {
  my $lslot = shift;
  $lslot=get_logical_unit($lslot) if ($lslot =~ /^S\d+(S\d+)?$/i); 
  return "" if( !check_lslot($lslot) );

  my $card = $LOGICALUNIT[num_only($lslot)];
  return "" unless defined($card->{"psum"}) ;

  my $t_cur   = time();
  my $t_cache = $card->{"t_psum"};
  my $LS = $card->{"LS"};

  if( ($t_cur - $t_cache) <= $PSUM_CACHE_TIME ) {
    if ( $verbose == 1 ) {
      printlog( "Using cached psum($lslot)\n" );
    }
    return join(" ", @$LS);
  }

  my $prop_idx = $card->{"propidx"};
  my $psum = psum($lslot);
  my @new_state = split(/\s+/, $psum);
  @new_state = @new_state[2 .. $#new_state];
  my @old_state = @{$card->{"psum"}};
  $card->{"psum"} = \@new_state;
  $card->{"t_psum"} = $t_cur;

  my $resp;

  ## Look for change in measured values
  for my $prop ( keys( %{ $LS_PROP_LIST{"MEASURED"}{"test_params"} }) ) {
    printlog("$old_state[$prop_idx->{$prop}]"."\n");
    printlog("$new_state[$prop_idx->{$prop}]"."\n");
    if( $old_state[$prop_idx->{$prop}] ne $new_state[$prop_idx->{$prop}] ) {
      # poll card for prop in all channels
      my @old = @{$card->{$prop}};
      $resp = recall($lslot, $prop);
      my @new = split(/\s+/, $resp);
      @new = @new[3 .. $#new];    # knock off the first three response elements
      $card->{$prop} = \@new;
      my $c=0;
      for(my $i=0; $i<$#old; $i++) {
        $c++ if( abs($new[$i] - $old[$i]) >= $LS_PROP_LIST{"MEASURED"}{"test_params"}{$prop}{"min_change"} );
      }
      # Increment the measured 'change' counter in LS list.
      $LS->[0] = incr_hex($LS->[0], $c);
    }
  }
  # Generate 'change' counter in LS list.  There are two words per card.
  #   The first  word flags changes in measured values (current/voltage)
  #   The second word flags changes in demand values
  return join(" ", @$LS);
}

## Increment a hex string (and return a wrapped 4 char hex string)
sub incr_hex($$) {
  my $val = shift;
  my $c   = shift;

  return sprintf("%04X", (hex($val)+$c)%65536);
}

## Return a hash that maps array value to its array index
sub hash_index {
  my %hash;
  for(my $i=0; $i<$#_; $i++) {
    $hash{$_[$i]} = $i;
  }
  return \%hash;
}

## Return the 'LL' submodule list
sub LL_filled_slots() {
  return "LL" . $CRATE{"LL"};
}


## Convert the logical unit (Ln) or submodule (SnSm) notation to a slot, submodule
sub get_slot_submod($) {
  my $lslot = shift;

  return @{$CRATE{"get_slot_subm"}{$lslot}} if(check_slot($lslot));

  return (-1, -1);
}

## Convert the submodule (SnSm) notation into logical unit (Ln)
sub get_logical_unit($) {
  my $sslot = shift;
  my $tmp = $CRATE{"get_logical_unit"}->{$sslot};
  if( !defined($tmp) ) {
    printlog("Invalid slot id ($sslot)");
    return;
  } else {
    return $tmp;
  }
}

## Return the numeric part of L<num>
sub num_only($) {
  my $tmp = shift;
  if($tmp =~ /\w?(\d+)/) {
    return $1+0;
  } else {
    printlog("'$tmp' has strange format");
    return $tmp;
  }
}

## Test to see if unit exists in @LOGICALUNIT
sub check_lslot($) {
  my $lslot = shift;
  return check_slot($lslot) if ($lslot =~ /^L\d+$/i);
  printlog("Invalid lslot($lslot)");
  return 0;
}
sub check_slot($) {
  my $lslot = shift;
  my $slot = num_only($lslot);
  if( ($lslot =~ /\d+/) and (defined $LOGICALUNIT[$slot]) ) {
    return 1;
  }
  printlog("Invalid slot($lslot/$slot)");
  return 0;
}

## Handle PSUM command: return property summary for module
sub psum($) {
  my $lslot = shift;
  my $cmd = "PSUM";
  my ($lunit, $resp) = generic_cmd($cmd, $lslot);
### add one more number for 'RLY' support
    if( defined($resp) ) {
	if ($RLY_USE ) {
	    if ( ($lslot eq $rlyparams{"slot"} or $lslot eq $rlylu) ) {
		$resp .= " $rly_psum";
	    }
	}
    }
  return sprintf("%s %s %s", $cmd, $lunit, $resp);
}

## Handle PROP command: return property list for a slot
sub properties($) {
  my $lslot = shift;
  my $cmd = "PROP";
  my ($lunit, $resp) = generic_cmd($cmd, $lslot);
### add one more property for 'RLY' support
    if( defined($resp) ) {
	if ($RLY_USE ) {
	    if ( ($lslot eq $rlyparams{"slot"} or $lslot eq $rlylu) ) {
		$resp .= " RLY";
	    }
	}
    }
  return sprintf("%s %s %s", $cmd, $lunit, $resp);
}

## Handle ATTR command: return attribute list for a property
sub attributes($$) {
  my $lslot = shift;
  my $attr = shift;
  my $cmd = "ATTR";
  ### add  attribute for 'RLY' support
    if ( $RLY_USE ) {
	if ( ($lslot eq $rlyparams{"slot"} or $lslot eq $rlylu) ) {
	    if( $attr eq "RLY" ) {
  ### this is settable RLY property		
		my $rsp = "RLY_En na N N 0_1_1 \%2s";
 ### this is measurable RLY property
##		my $rsp = "RLY_En na M N 1 \%2s";
		return sprintf("%s %s %s %s", $cmd, $lslot, $attr, $rsp);
  ### this is measurable RLY property		
##  		return   $resp = "$command $lslot $attr RLY_En na M N 1 %2s";
	    }
	}
    }
  my ($lunit, $resp) = generic_cmd("$cmd $attr", $lslot);
  return sprintf("%s %s %s %s", $cmd, $lunit, $attr, $resp);
}

## Handle DMP command: return list of channel information
sub dmp($$) {
  my $lslot = shift;
  my $chan = shift;
  my $cmd  = "DMP";
  my ($lunit, $resp) = generic_cmd("$cmd $chan", $lslot);
  return sprintf("%s %s.%d %s", $cmd, $lunit, $chan, $resp);
}

## Handle ID command: return card identification
sub id($) {
  my $lslot = shift;
  my $cmd  = "ID";
  my ($lunit, $resp) = generic_cmd($cmd, $lslot);
### inctrement property number for 'RLY' support
    if( defined($resp) ) {
##	printlog("ID resp=$resp");
	if ($RLY_USE ) {
	    if ( ($lslot eq $rlyparams{"slot"} or $lslot eq $rlylu) ) {
		# increment number of properties(4th element after 'lslot') by 1
		my @arr =  split(/\s+/, $resp);
		if( $arr[3] =~ /^\d+$/) { 
		    $arr[3]++;
		}
		$resp=join(" ", @arr);
		printlog("--->>>$resp\n");
	    }	    
	}
    }
  return sprintf("%s %s %s", $cmd, $lunit, $resp);
}

## Handle RC command: return a channel list with information on a property
sub recall($$) {
  my $lslot = shift;
  my $attr = shift;
  my $cmd  = "RC";

  my ($lunit, $resp) = generic_cmd("$cmd $attr", $lslot);
  return sprintf("%s %s %s %s", $cmd, $lunit, $attr, $resp);
}

## Handle LD command: set a property value on a card
sub load($$$@) {
  # Client to bbps1:2002:LD L12 CE 1 1 1 1 1 1 1 1 1 1 1 1
  # Client to bbps1:2002:LD L14.0 CE 1
  my $lslot = shift;
  my $chan = shift;
  my $attr = shift;
  my $cmd  = "LD";
  my @args = @_;

  $lslot=get_logical_unit($lslot) if ($lslot =~ /^S\d+(S\d+)?$/i); 
  return "" if( !check_lslot($lslot) );
  my $card = $LOGICALUNIT[num_only($lslot)];
  my $num_chan = $card->{"num_chan"};
  my $propidx = $card->{"propidx"};

  if( ! exists( $propidx->{$attr} ) ) {
    printlog("Invalid ATTR($attr)");
    return "";
  }

  my $min_chan=0;
  my $max_chan=0;
  if( $chan eq "" ) {
    $min_chan=0;
    $max_chan=$num_chan;
  } else {
    $min_chan=$chan;
    $max_chan=$chan + scalar(@args);
  }
  if( $max_chan > $num_chan ) {
    printlog(sprintf("arglist length(%s) exceeds num_chan($chan .. $num_chan)", join(" ", @args)));
    return "";
  }

  ## Update 'DEMAND' change flag for this logical unit
  my $LS = $card->{"LS"};
  my $idx = $LS_PROP_LIST{DEMAND}{"idx"};
  $LS->[$idx] = incr_hex($LS->[$idx], 1);

  ## Update 'DEMAND' change flag in GS
  my ($lunit, $resp) = generic_cmd(sprintf("$cmd $attr $min_chan %s", join(" ", @args)), $lslot);
  update_GS_status("DEMAND");

  $lunit = sprintf("%s%s", $lunit, $chan eq "" ? "" : ".$chan");
  return sprintf("%s %s %s %s %s", $cmd, $lunit, $attr, $resp, join(" ", @args));
}

## Turn the HV on or off for all cards in crate
sub HV_card_power($) {
  my $cmd    = shift;

  if( $cmd !~ /(HVOFF)|(HVON)/i ) {
    printlog("Invalid command '$cmd'");
    return "";
  }

  my $resp;
  foreach my $card ( @LOGICALUNIT ) {
    my $slot   = $card->{"slot"};
    my $submod = $card->{"submod"};
    my $lslot =  $card->{"lslot"};
    ($lslot, $resp) = generic_cmd($cmd, $lslot);
  }

  # check if it worked
  $resp = poll_HV_status();

  printlog("Response to poll_HV_status() = '$resp'");

  $CRATE{"GS"}{"MFCONF"}++;
  update_GS_status("MEAS");  # force a change status here

  #FIXME?: need to verify what the expected response is here
  return "$cmd" if($resp =~ /$cmd/i);
  return "";
}

## Run through crate array and check HV status
sub poll_HV_status() {
  my $cmd = "HVSTATUS";
  $HVserverIO->clear_accum();

  my $HVon=0;
  foreach my $card ( @LOGICALUNIT ) {
    my $slot =  $card->{"slot"};
    my $submod = $card->{"submod"};
    my $remcmd = sprintf("%d %d %s\r\n", $slot, $submod, $cmd);
    $HVserverIO->send( $remcmd );
    $HVserverIO->expect($HV_server_timeout,
 
  #   [ qr/\($slot,\s*$submod\):.+?$slot\s+$cmd\s+([^\r]*?)\r*\n/i,
      [ qr/$slot\s+$cmd\s+([^\r]*?)\r*\n/i,
        sub { my $self = shift;
              if( ($self->matchlist)[0] !~ /(HVOFF)|(HVON)/i ) {
                printlog(sprintf("warning: strange response for '$remcmd': %s", $self->match));
              }
              $HVon++  if( ($self->matchlist)[0] =~ /HVON/i );
              exp_continue; }
              ],
      [ qr/$MF_READY_PROMPT/ ]
    );
    printlog( $HVserverIO->error()) if( $HVserverIO->error() );
  }

  $CRATE{"GS"}{"MFACTV"}++;

  if( $HVon > 0 ) {
    $HVconfigW0{"statusHVstate"} =1<<13;  # (2 bit) 0=HVOFF, 1=HVON, 2=HV changing, 3=HV unknown
    return "$cmd HVON\n";
  } else {
    $HVconfigW0{"statusHVstate"} =0<<13;  # (2 bit) 0=HVOFF, 1=HVON, 2=HV changing, 3=HV unknown
    return "$cmd HVOFF\n";
  }
}

##
## Generic command handler for Lecroy 1458 crate
##
sub generic_cmd($$) {
  my $cmd    = shift;
  my $lslot  = shift;

  if ( $verbose == 1 ) {
    printlog "generic_cmd($cmd, $lslot)";
  }

  $lslot=get_logical_unit($lslot) if ($lslot =~ /^S\d+(S\d+)?$/i); 
  return "" if( !check_lslot($lslot) );
  my ($slot, $submod) = get_slot_submod($lslot);

  my @resp_match;
 ## my $remcmd = sprintf("%d %d %s\n", $slot, $submod, $cmd);
  my $remcmd = sprintf("%d %d %s\r\n", $slot, $submod, $cmd);

  if ( $verbose == 1 ) {
    printlog "remcmd: $remcmd";
  }

  $HVserverIO->clear_accum();

##  $HVserverIO->send( $remcmd ); # this is send only 80 characters? Why?
    print $HVserverIO "$remcmd";  # this is work;

## The response string seems to contain a \006 (ACK) after the '($slot,$sub):'
  #  bit.  It may also have an indeterminate number of \r's at the end.  This
  #  was fun to debug...
 # $HVserverIO->expect($HV_server_timeout,
 #   [ qr/\($slot,$submod\):.+?($slot)\s+($cmd)\s+([^\r]+?)[\r\n]+/i =>
 #     sub { my $self = shift;
 #           @resp_match = ($self->matchlist);  ## slot, cmd, response
 #           exp_continue; }
 #           ],
 #   [ qr/$MF_READY_PROMPT/ ]
 # );
  $HVserverIO->expect($HV_server_timeout,
#    [ qr/\($slot,$submod\):.+?($slot)\s+($cmd)\s+([^\r]+?)[\r\n]+/i =>
     [ qr/($slot)\s+($cmd)\s+([^\r]+?)[\r\n]+/i =>
      sub { my $self = shift;
            @resp_match = ($self->matchlist);  ## slot, cmd, response
            exp_continue; }
            ],
	[ qr/$MF_READY_PROMPT/ ]
  );


  printlog( $HVserverIO->error() ) if( $HVserverIO->error() );

  ##printlog("generic_cmd response:  <$resp_match[0]>, <$resp_match[1]>,  <$resp_match[2]>");

  $CRATE{"GS"}{"MFACTV"}++;
  return $lslot, defined($resp_match[2]) ? $resp_match[2] : "";
}

##
## Initialize the @LOGICALUNIT structure for a LeCroy 1458 crate
##
sub init_LeCroy1458($) {
  printlog("init_LeCroy1458");
  my $server = shift;
  @LOGICALUNIT = ();    ## Clear the logical unit array\
  %CRATE = ();          ## Clear the CRATE hash

  my @cardlist;

  sleep(5);
  my $count=0;
  $server->clear_accum();
  #$server->restart_timeout_upon_receive(1);
  $server->send("\r\n");
  $server->expect(30,
    [ qr/$MF_READY_PROMPT/ ]
  ) || die("Can't connect to mainframe\n");

  sleep(2);
  $server->restart_timeout_upon_receive(0);
  $server->clear_accum();
  $server->send("_LL\r\n");
##  this is for Expect with serial interface	
  #$server->expect($HV_server_timeout,
  #  [ qr/\d+ [\d]+\w? .+?[\r\n]+/i =>
  #    sub { my $self = shift;
  #          push (@cardlist, $self->match() );
  #          exp_continue; }
  #          ],
  #  [ qr/$MF_READY_PROMPT/ ]
  #);
 $server->expect($HV_server_timeout,
    [ qr/\d+ [\d]+\w? .+?[\r\n]+/i =>
      sub { my $self = shift;
            push (@cardlist, $self->match() );
            exp_continue; }
            ],
    [ qr/$MF_READY_PROMPT/ ]
  );
  carp( $server->error() ) if( $server->error() );

  open(my $SLFH, ">", $slotlistfile);
  for my $card ( @cardlist ) {
      print $SLFH  "$card\n";
    LL_add_crate( $card );
  }
  close($SLFH);

  ## poll the HV status (which updates the CONFIG flag)
  my $resp = poll_HV_status();
### 15-Mar-2017
## init relay server parameters
  if( rly_init() ) {
     foreach my $card ( @LOGICALUNIT ) {
       my $slot =  $card->{"slot"};
       my $lslot =  $card->{"lslot"};
       if( $slot==num_only($rlyparams{"slot"}) ) { 
         # check if slot num from relay config file is present in hv craate
         printlog(">> rly_init(): slot=$slot  logunit=$lslot  relay_slot=$rlyparams{'slot'} <<\n");	
	 $rlylu=$lslot; # keep it for check relay slot in parse_host_cmd() function
	 $RLY_USE=1; # use relay server
	 printlog("OK! Using relay server for module in slot=$slot\n");
##	 my $resp=rly_send("LD S0 RLY 0 0 0 0 0 0 0 0"); # turn all relays to OFF (resisor IN)
##	 printlog("Switch all relays to OFF!!: $resp\n");

       } else {
#       print(">>slot=$slot  lu=$lslot<<\n");
         printlog(">> Not found relay_slot=$rlyparams{'slot'} for slot=$slot <<\n")  if(!$RLY_USE);
	}
     }
    
#     (my $sl, my $sm) =  get_slot_submod("L0"); 
#     print("[$sl , $sm] \n");

  } else {
     printlog(">> NO Relay config file: $rlyfilename <<\n");
         #	  print("NO connection to relay server: $rlyparams{'host'}:$rlyparams{'port'} \n");	  
  }  # init relay server parameters 

  return;
}

## Accepts output from _LL command and assembles the @LOGICALUNIT structure
#  @LOGICALUNIT[<physical slot number>]
sub LL_add_crate($) {
  my $line = shift;
  my %card;
  push @LOGICALUNIT, \%card;

  printlog("New card: $line");

  $line =~ s/[\r\n]//g;
  my @f = split(/\s+/, $line);
  
  $card{"ID"} = $line;
  $card{"slot"} = $f[0]+0;
  $card{"type"} = $f[1];
  $card{"submod"} = $f[2]+0;
  $card{"num_submod"} = $f[3]+0;
  $card{"prop_count"} = $f[4]+0;
  $card{"num_chan"} = $f[5]+0;
  $card{"serial_num"} = $f[6];

  ## Initialize null lists for these properties here.  They will get filled on
  #  the first LS_status
  my $LS_prop_count=0;
  for my $prop ( keys(%{$LS_PROP_LIST{MEASURED}{test_params}}) ) {
    if ( $verbose == 1 ) {
      printlog("prop: $prop\n");
    }
    $card{$prop} = [];
    $LS_prop_count++;
  }
  @f = ( "0000" ) x $LS_prop_count;
  $card{"LS"} = [ @f ];

  my $lslot = "L".$#LOGICALUNIT;

  ## ADD to the %CRATE structure
  my $LL_resp;
  my $nLogical=$#LOGICALUNIT;
  my $logicU = sprintf("L%d", $nLogical);
  my $slot =  $card{"slot"};
  my $submod = $card{"submod"};
  my $num_submod = $card{"num_submod"};
  my $num_chan = $card{"num_chan"};
  my $modU; 
  if( $num_submod == 1 ) {
    $modU = sprintf("S%d", $slot);
  } else {
    $modU = sprintf("S%dS%d", $slot, $submod);
  }
  $card{"lslot"} = $logicU;
  $card{"sslot"} = $modU;


  $CRATE{"get_slot_subm"}{$logicU} = [$slot, $submod];
  $CRATE{"get_logical_unit"}{$modU} = $logicU;
  $CRATE{"LL"} .= " $modU";

  $CRATE{"GS"} = { "MEAS"     => 0,   # incremented when a measured value has changed
                   "DEMAND"   => 0,   # incremented when a demand value has changed
                   "MFCONF"   => 0,   # incremented when mainframe config has change
                   "MFACTV"   => 0,   # incremented on mainframe activity
                   "HOSTACTV" => 0};  # incremented on host activity                  (not used)
  $CRATE{"t_GS_meas"} = 0;
  $CRATE{"LS"} = "";

  @f = split(/\s+/, properties($lslot) );
  $card{"propidx"} = hash_index(@f[2..$#f]);  # knock off the slot, command
  @f = split(/\s+/, psum($lslot) );
  @f = @f[2 .. $#f];  # knock off the slot, command
  $card{"psum"} = [ @f ];
  $card{"t_psum"} = time();
}

1;  ## do not delete this line
